var documenterSearchIndex = {"docs":
[{"location":"api/#API-documentation","page":"API","title":"API documentation","text":"","category":"section"},{"location":"api/#Data-Sources","page":"API","title":"Data Sources","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Data from arbitrary file formats can be used as long as they return an array of values when provided with a string.","category":"page"},{"location":"api/","page":"API","title":"API","text":"DataSource\nTypedDataSource","category":"page"},{"location":"api/#CrystalInfoContainers.DataSource","page":"API","title":"CrystalInfoContainers.DataSource","text":"A DataSource, when provided with a string referring to a data name from a namespace known to the data source, returns an array of values that are either Native (already Julia types) or Text (requiring interpretation to create Julia types).\n\n\n\n\n\n","category":"type"},{"location":"api/#CrystalInfoContainers.TypedDataSource","page":"API","title":"CrystalInfoContainers.TypedDataSource","text":"TypedDataSource(data,dictionary)\n\nA TypedDataSource is a DataSource that returns items with the correct type and aliases resolved, as specified in the associated CIF dictionary. The dictionary also provides a namespace.\n\n\n\n\n\n","category":"type"},{"location":"#CrystalInfoContainers.jl","page":"Overview","title":"CrystalInfoContainers.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This module leverages the International Union of Crystallography's  Crystallographic Information Framework (CIF) dictionary standard to return typed information from arbitrary data sources. Data from those sources can be manipulated within the relational framework defined by the dictionaries.","category":"page"},{"location":"tutorial/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"The CIF files used in these examples are provided in the docs directory.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"This module combines CIF dictionaries with arbitrary data sources to simplify manipulation, typing and calculations of objects within those data sources.","category":"page"},{"location":"tutorial/#DataSources","page":"Guide","title":"DataSources","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"CIF dictionaries can be used with any DataSource, providing that the datasource recognises the data names defined in the dictionary.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A DataSource is any object returning an array of values when supplied with a string - where that string is typically a CIF data name.  A CIF Block conforms to this specification, as does a simple Dict{String, Any}.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A CIF dictionary can be used to obtain data with correct Julia type from a DataSource that uses data names defined in the dictionary by  creating a TypedDataSource:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"using CrystalInfoContainers, CrystalInfoFramework, DataFrames\nnc = Cif(\"demo.cif\")\nmy_block = nc[\"saly2_all_aniso\"]  #could also use first(nc).second\nmy_dict = DDLm_Dictionary(\"../test/cif_core.dic\")\nbd = TypedDataSource(my_block,my_dict)\nbd[\"_cell.length_a\"]\n\n# output\n\n1-element Vector{Float64}:\n 11.52\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Note that the array elements are now Float64 and that the standard uncertainty has been removed. Future improvements may use Measurements.jl to retain standard uncertainties. Meanwhile, SUs are available by appending _su to the data name.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Dictionaries also allow alternative names for a data name to be recognised provided these are noted in the dictionary:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"\nl = bd[\"_cell_length_a\"] #no period in name\n\n# output\n\n1-element Vector{Float64}:\n 11.52\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"where _cell_length_a is the old form of the data name.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Currently transformations from DataSource values to Julia values assume that the DataSource values are either already of the correct type, or are Strings that can be directly parsed by the Julia parse method.","category":"page"},{"location":"tutorial/#Creating-new-DataSources","page":"Guide","title":"Creating new DataSources","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A file format can be used with CIF dictionaries if:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"It returns an Array of values when provided with a data name defined in the dictionary\nArrays returned for data names from the same CIF category have corresponding values at the same position in the array - that is, they line up correctly if presented as columns in a table.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"At a minimum, the following methods should be defined for the DataSource:  getindex, haskey.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"If the above are true of your type, then it is sufficient to define DataSource(::MyType) = IsDataSource() to make it available.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"If a DataSource can instead be modelled as a collection of DataSources, iterate_blocks should also be defined to iterate over the constituent DataSources. MultiDataSource(<file>) will then create a DataSource where values returned for any data names defined in the constituent blocks are automatically aligned. Such MultiDataSource objects can be built to form hierarchies.","category":"page"},{"location":"tutorial/#Types","page":"Guide","title":"Types","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A TypedDataSource consists of a DataSource and a CIF dictionary.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"Values returned from a TypedDataSource are transformed to the appropriate Julia type as specified by the dictionary if the underlying  DataSource returns String values formatted in a way that Julia parse can understand.  Otherwise, the DataSource is responsible for returning the appropriate Julia type. Future improvements may add user-defined transformations if that proves necesssary.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A NamespacedTypedDataSource includes data from multiple namespaces. Correctly-typed data for a particular namespace can then be obtained from  the object returned by select_namespace(t::NamespacedTypedDataSource,nspace).","category":"page"},{"location":"tutorial/#Relational-containers","page":"Guide","title":"Relational containers","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"CIF dictionaries organise data names into relations (tables). These relations are strictly conformant to the relational model. A RelationalContainer is an object created from a DataSource and CIF dictionary which provides a relational view of DataSource, that is, data are organised into tables according to the dictionary specifications.","category":"page"},{"location":"tutorial/#Cif-Categories","page":"Guide","title":"Cif Categories","text":"","category":"section"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A CIF category (a 'Relation' in the relational model) can be returned from a RelationalContainer given the category name:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"\nrc = RelationalContainer(my_block, my_dict)  # Use DataSource to create RelationalContainer\nas = LoopCategory(rc, \"atom_site\")\n\n# output\n\nCategory atom_site Length 10\n10×7 DataFrame\n Row │ fract_x   fract_z    label  adp_type  u_iso_or_equiv  occupancy  fract_ ⋯\n     │ Any       Any        Any    Any       Any             Any        Any    ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ .5505(5)  .1605(11)  o1     Uani      .035(3)         1.00000    .6374( ⋯\n   2 │ .4009(5)  .2290(11)  o2     Uani      .033(3)         1.00000    .5162(\n   3 │ .2501(5)  .6014(13)  o3     Uani      .043(4)         1.00000    .5707(\n   4 │ .4170(7)  .4954(15)  c1     Uani      .029(4)         1.00000    .6930(\n   5 │ .3145(7)  .6425(16)  c2     Uani      .031(5)         1.00000    .6704( ⋯\n   6 │ .2789(8)  .8378(17)  c3     Uani      .040(5)         1.00000    .7488(\n   7 │ .3417(9)  .8859(18)  c4     Uani      .045(6)         1.00000    .8529(\n   8 │ .4445(9)  .7425(18)  c5     Uani      .045(6)         1.00000    .8778(\n   9 │ .4797(8)  .5487(17)  c6     Uani      .038(5)         1.00000    .7975( ⋯\n  10 │ .4549(7)  .2873(16)  c7     Uani      .029(4)         1.00000    .6092(\n                                                                1 column omitted\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"where a category is either a LoopCategory, with one or more rows, or a SetCategory, which is restricted to a single row.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"getindex for CIF categories uses the indexing value as the key value for looking up a row in the category:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"one_row = as[\"o1\"]\none_row.fract_x\n\n# output\n\n\".5505(5)\"\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"If a category key consists multiple data names, a Dict{Symbol,V} should be provided as the indexing value, where Symbol is the object_id of the particular data name forming part of the key and V is the type of the values.","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"A category can be iterated over as usual, with the value of each dataname for each row available as a property:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"for one_row in as\n    println(\"$(one_row.label) $(one_row.fract_x) $(one_row.fract_y) $(one_row.fract_z)\")\nend\n\n# output\n\no1 .5505(5) .6374(5) .1605(11)\no2 .4009(5) .5162(5) .2290(11)\no3 .2501(5) .5707(5) .6014(13)\nc1 .4170(7) .6930(8) .4954(15)\nc2 .3145(7) .6704(8) .6425(16)\nc3 .2789(8) .7488(8) .8378(17)\nc4 .3417(9) .8529(8) .8859(18)\nc5 .4445(9) .8778(9) .7425(18)\nc6 .4797(8) .7975(8) .5487(17)\nc7 .4549(7) .6092(7) .2873(16)\n","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"If you prefer the DataFrame tools for working with tables, DataFrame(c::CifCategory) creates a DataFrame:","category":"page"},{"location":"tutorial/","page":"Guide","title":"Guide","text":"\nDataFrame(as)\n\n# output\n\n10×7 DataFrame\n Row │ fract_x   fract_z    label  adp_type  u_iso_or_equiv  occupancy  fract_ ⋯\n     │ Any       Any        Any    Any       Any             Any        Any    ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ .5505(5)  .1605(11)  o1     Uani      .035(3)         1.00000    .6374( ⋯\n   2 │ .4009(5)  .2290(11)  o2     Uani      .033(3)         1.00000    .5162(\n   3 │ .2501(5)  .6014(13)  o3     Uani      .043(4)         1.00000    .5707(\n   4 │ .4170(7)  .4954(15)  c1     Uani      .029(4)         1.00000    .6930(\n   5 │ .3145(7)  .6425(16)  c2     Uani      .031(5)         1.00000    .6704( ⋯\n   6 │ .2789(8)  .8378(17)  c3     Uani      .040(5)         1.00000    .7488(\n   7 │ .3417(9)  .8859(18)  c4     Uani      .045(6)         1.00000    .8529(\n   8 │ .4445(9)  .7425(18)  c5     Uani      .045(6)         1.00000    .8778(\n   9 │ .4797(8)  .5487(17)  c6     Uani      .038(5)         1.00000    .7975( ⋯\n  10 │ .4549(7)  .2873(16)  c7     Uani      .029(4)         1.00000    .6092(\n                                                                1 column omitted\n","category":"page"}]
}
